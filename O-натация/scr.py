# Алгоритм нахождения минимального элемента в последовательности:
seq = [...]  # дана последовательность элементов

min_ = seq[0]  # предполагаем что первый элемент минимальный
for i in range(len(seq)):  # перебираем все возможные индексы последовательности
    if seq[i] < min_:  # сравниваем текущий элемент с ранее найденым минимумом
        min_ = seq[i]  # если нашли, то перезаписываем
        break

# n -> сколько последовательностей приходит
# Запишем функцию  g(n)  описывающую количество операций,
# которое необходимо выполнить при поиске минимума:
# g(n) = 2 + 2N + N = 2 + 3N
# Используя асимптотическое равенство функций найдем функцию f(n):
# limn→∞  f(n)/g(n)=1
# f(n)  как раз и будет описывать O-большое


# Составляет функцию, описывающую алгоритм
# Находим доминирующий оператор по таблице.
# Оставляем только его, всё остальное отбрасываем. Потому что при  n→∞ ,
# доминирующий оператор будет доминировать (масло-маслянное :) )
# Если при доминирующем операторе есть множитель, его тоже отбрасываем.
# f(n)=limn→∞(g(n))=2+3N=3N=N
# O(f(n))=O(N)  - читается как O-большое от N